---
title: "Population genomic analyses of <i>Xylaria necrophora</i> from southern USA | Part 3: Sexual vs Clonal Analyses"
author: "Teddy Garcia-Aroca"
date: 'Last update: June 15th, 2023'
output:
  html_document: rmdformats::html_clean
pdf_document: default
---
  
# Description.
  
Population genetic analyses for 162 genomes of *Xylaria necrophora* from soybean collected in the southern United States from 2016-2020.

Using reasoning and code from https://grunwaldlab.github.io/Population_Genetics_in_R/
  
And some phylo-geography analyses based on [Shakya et. al. (2021)]( https://doi.org/10.1111/mec.16109)

# Install and load packages

With the following statements, we check if packages are installed and we install those that aren't.

```{r results='hide', message=FALSE, warning=FALSE}
packages <- c("adegenet", "ape", "dartR", "cowplot", "devtools", "dplyr", "ggplot2", "hierfstat", "igraph", "knitr", "lattice", "magrittr", "mmod", "pegas", "pinfsc50", "poppr", "RColorBrewer", "reshape2", "treemap", "vcfR", "vegan", "viridisLite")


# Install packages not yet installed

installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}


# Packages loading

invisible(lapply(packages, library, character.only = TRUE))
```

## Note: Some packages might need to be installed manually. 

An example is provided here if the initial installation of SNPRelate fails.

```{r}
#Install SNPRelate dependency with BiocManager

#if (!require("BiocManager", quietly = TRUE))
#  install.packages("BiocManager")
#BiocManager::install(version = "3.15")

#BiocManager::install("SNPRelate")

#library("devtools")
#install_github("zhengxwen/SNPRelate",force = TRUE)

#SNPRelate can be tricky to install on a mac. If none of that works, then try these steps:

#1. Install homebrew
#Open the Terminal app and type:
 # > ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
#2. Install Command-Line tools
#In the Terminal app type:
 # > xcode-select --install
#3. Install compiler
#In the Terminal app type:
  #> brew install gcc
#4. Make a symlink from your gcc version to gcc
#In the Terminal app type:
  #> ln -s gcc-11 gcc
#5. Create a makevars file and put the path to libgfortran into FLIBS
#In the R console type 
#> dir.create('~/.R')
#> write.table("FLIBS=`gfortran -print-search-dirs | grep '^libraries:' | sed 's|libraries: =||' | sed 's|:| -L|g' | sed 's|^|-L|'`",file='~/.R/Makevars',col.names = FALSE,row.names = FALSE,quote = FALSE)
#6. Install SNPRelate
#In the R console type:
#  > install.packages("SNPRelate")
#7. Install dartR
#In the R console type:
 # > install.packages("dartR")
#BiocManager::install("SNPRelate")
```

# Or load specific packages needed for analyses (If preferred)

With these statements we load the specific packages needed for our analyses

```{r}
library("poppr")
library(dartR)
library(mmod)
library(vcfR)
library(poppr)
library(ape)
library(RColorBrewer)
library(ggplot2)
library(reshape2)
library("ggpubr")
```

# Set the working directory (wd)

We set our wd to where the root project would be. In this case:

```{r}
setwd("~/Dropbox/work/AssistantProfessorUNL/manuscripts/drafts/X_necrophoraPopGen/GitHub/X_necrophora_pop_gen/RStudio/")
```

# Load the variant calling format file (vcf) from our SNP calling pipelines

Using the R package vcfR, we can read VCF format files into memory using the function read.vcfR(). Once in memory we can use the head() method to summarize the information in the three VCF regions.

We load several files to see the effects of filtering

```{r}
vcf1 <- read.vcfR("../input/Xylaria_163_genomes.MinQG30.MinDP2.MaxMiss0.7.recode.Homozygous.recode.recode.vcf.maf.ld.0.1.vcf")
#vcf2 <- read.vcfR("../input/Xylaria_166_genomes.MinQG30.MinDP5.MaxMiss0.7.recode.Homozygous.recode.recode.vcf.maf.ld.0.1.vcf")
```

### Convert to genind

Now, we convert our vcf object into a genind object for further analyses.

```{r}
my_genind <- vcfR2genind(vcf1)
```

You may see a warning that reads (if 175 genotypes file was loaded):
"Individuals with no scored loci have been removed"

This means that empty genotypes were removed at the moment of conversion to a genind object

Now, lets check the number of individuals in this object:


```{r}
nInd(my_genind)
```

As you see, this object has a total of 163 genotypes (all necrophora), 162 *X. necrophora* comtemporary (161 from soybean + one from forests in the island of Martinique) + one historical specimen from sugarcane found in Louisiana in 1938 [Garcia-Aroca et al. (2021)](https://doi.org/10.1080/00275514.2020.1846965). Some individuals were filtered out in this vcf file  on the bases of missing data (more than 70% missing data) with vcftools (see materials and methods).

The following code block extracts names from our genind to match with values in our metadata file with the ultimate goal of adding strata to our genind and genclone objects.

# Load metadata

We load metadata needed for analyses

```{r}
pop.data <- read.table("../metadata/Xylaria_175_genomes.popdata.Updated.10.30.2022.csv", sep = ",", header = TRUE)
```

If loading a vcf files with 175 genotypes (complete dataset), check that all the data is contained in our pop.data matches the data contained in our vcf

```>all(colnames(vcf@gt)[-1] == pop.data$No)```

However, our current dataset contains 163 X. necrophora strains only.

```{r}
# Add pop data to each object in our list of geninds (has to be done separately as each may have a different number of individuals)

#Extract labels as vector
newNames <- as.vector(adegenet::indNames(my_genind))
     #Subset those from original pop data
pop.data2 <- pop.data[pop.data$ID_ID %in% newNames,]
     #Add new strata to genind
strata(my_genind) <- pop.data2

my_genind
```

# Change ploidy to our genind

Set ploidy to 1 (Haploid)

```{r}
ploidy(my_genind) <- 1
```

Convert to genclone objects

```{r}
my_genclone <-poppr::as.genclone(my_genind)
```

Now we set the strata to the desired population

```{r}
# We add the ploidy statement again, just in case.
ploidy(my_genclone) <- 1

# Set population to the original known populations
setPop(my_genclone) <- ~State

```

# Extra filtering

Let's filter each dataset for missing loci. Note: All loci with more than 90% data have been removed in vcftools (see materials and methods)

```{r}
my_genclone.filtered <- missingno(my_genclone, type = "loci", cutoff = 0.9, quiet = FALSE, freq = FALSE)
```

Now, let's take a look at what the missing data looks like if we further filter to more than 90 % missing data (Suppementary Figure 1).

```{r}
my_genclone %>% missingno("loci", cutoff = 0.9) %>% info_table(plot = TRUE, scale = FALSE)
```
Now, let's filter out genotypes with more than 90% missing data

```{r}
my_genclone.filtered <- missingno(my_genclone, type = "geno", cutoff = 0.9, quiet = FALSE, freq = FALSE)
```

Four genotypes were removed on the basis of missing data, including a historical specimen from Louisiana collected in 1938 on sugarcane. This is expected since the quality genotypes from these historical specimens was not expected to be high.

```{r}
my_genclone %>% missingno("geno", cutoff = 0.9) %>% info_table(plot = TRUE, scale = FALSE)
```

Since we removed individuals with missing data over 90% was found, we now have two datasets: "unfiltered" dataset with all 163 individials, meaning this is the dataset that was not further filtered in R (only filtered in vcf tools) and one "filtered" dataset with 159 individuals after removing individual genotypes with more than 90% missing data.

Now, we can move on to the analyses.

First, we convert to genlight:

```{r}
gl.necrophora <- gi2gl(my_genind)

my_genind.filtered <- genclone2genind(my_genclone.filtered)

gl.necrophora.filtered <- gi2gl(my_genind.filtered)
```

Now we add strata, set ploidy and populations to genlight objects

```{r}
names.filtered <- gl.necrophora$ind.names
newNames <- as.vector(names.filtered)
#Subset those from original pop data
pop.data3 <- pop.data[pop.data$ID_ID %in% newNames,]
strata(gl.necrophora) <- pop.data3
setPop(gl.necrophora) <- ~State
ploidy(gl.necrophora) <- 1


names.filtered <- gl.necrophora.filtered$ind.names
newNames <- as.vector(names.filtered)
#Subset those from original pop data
pop.data4 <- pop.data[pop.data$ID_ID %in% newNames,]
strata(gl.necrophora.filtered) <- pop.data4
setPop(gl.necrophora.filtered) <- ~State
ploidy(gl.necrophora.filtered) <- 1

```

# Calculate Standardized Index of Association (SIA)

The null hypothesis for these analyses is that the standardized index of association is close to or not significantly different from zero if sexual recombination is common within these populations.

## Each dataset

Here, we calculate the SIA for each dataset (unfiltered, n=163 and filtered, n=)

```{r}
setPop(my_genclone) <- ~Hyp_Final

#Standardized Index of Association for entire dataset
ia.complete <- ia(my_genclone, sample = 999)
ia(my_genclone, sample = 999)


setPop(my_genclone.filtered) <- ~Hyp_Final

#Standardized Index of Association for entire dataset
ia.complete <- ia(my_genclone.filtered, sample = 999)
ia(my_genclone.filtered, sample = 999)

```

## lineage 1

We run the same analysis for lineage 1

```{r}

#Lin 1 Standardized index of association
setPop(my_genclone) <- ~Hyp_Final  
Lin1.subpop <- popsub(my_genclone, "Lin1")
ia.lin1 <- ia(Lin1.subpop, sample = 999)
ia(Lin1.subpop, sample = 999)


#Lin 1 Standardized index of association (Filtered dataset)
setPop(my_genclone.filtered) <- ~Hyp_Final  
Lin1.subpop <- popsub(my_genclone.filtered, "Lin1")
ia.lin1 <- ia(Lin1.subpop, sample = 999)
ia(Lin1.subpop, sample = 999)
```

## lineage 2

We run the same analysis for lineage 2

```{r}
#Lin 2 Standardized index of association
setPop(my_genclone) <- ~Hyp_Final  
Lin2.subpop <- popsub(my_genclone, "Lin2")
ia.lin2 <- ia(Lin2.subpop, sample = 999)
ia(Lin2.subpop, sample = 999)


#Lin 2 Standardized index of association (Filtered dataset)
setPop(my_genclone.filtered) <- ~Hyp_Final  
Lin2.subpop <- popsub(my_genclone.filtered, "Lin2")
ia.lin2 <- ia(Lin2.subpop, sample = 999)
ia(Lin2.subpop, sample = 999)
```



## lineage 3

```{r}
#Lin 3 Standardized index of association
setPop(my_genclone) <- ~Hyp_Final  
Lin3.subpop <- popsub(my_genclone, "Lin3")
ia.lin3 <- ia(Lin3.subpop, sample = 999)
ia(Lin3.subpop, sample = 999)

#Lin 3 Standardized index of association (Filtered dataset)
setPop(my_genclone.filtered) <- ~Hyp_Final  
Lin3.subpop <- popsub(my_genclone.filtered, "Lin3")
ia.lin3 <- ia(Lin3.subpop, sample = 999)
ia(Lin3.subpop, sample = 999)
```


Altogether, these results suggest we should reject the null hypothesis of sexual recombination because all p-values were lower than 0.05.

# Calculate, simulate, and plot Indexes of Association

Given that the SIA analyses suggested no sexual recombination, we explored the approach used by [Shakya et. al. (2021]( https://doi.org/10.1111/mec.16109) to compare the index of associations (non-standardized) from simulated sexual, semi-clonal, mostly-clonal, and completly clonal populations to those of *X. necrophora* and its lineages.

```{r}
setPop(gl.necrophora) <-  ~Hyp_Final
```

#Full datasets (all lineages)

```{r}
#t <- seppop(gl.necrophora)
t1 <- clonecorrect(as.snpclone(gl.necrophora))
#t2 <- clonecorrect(as.snpclone(t$Lin2))

set.seed(100)
sex <- glSim(n.ind = nInd(t1), n.snp.nonstruc = ceiling(0.9*nLoc(t1)), n.snp.struc = floor(0.1*nLoc(t1)), ploidy=1, LD=TRUE)
### Structure (clonal pops)
clone <- glSim(nInd(t1), n.snp.nonstruc = floor(0.1*nLoc(t1)), n.snp.struc=ceiling(0.9*nLoc(t1)), ploidy=1, LD = T)
### Semi-clonal 
semi_clone <- glSim(nInd(t1),n.snp.nonstruc = 0.5*nLoc(t1), n.snp.struc= 0.5*nLoc(t1), ploidy=1, LD=T)
### Most-clonal 
most_clone <- glSim(nInd(t1), n.snp.nonstruc = ceiling(nLoc(t1)/3), n.snp.struc=2*nLoc(t1)/3, ploidy=1, LD=T)

## IA sex
ia.sex <- samp.ia(sex,quiet = T, reps = 1000, n.snp = 400)
## IA clone
ia.clone <- samp.ia(clone, quiet = T, reps = 1000, n.snp = 400)
## IA.semiclone
ia.semi <- samp.ia(semi_clone, quiet = T,reps = 1000, n.snp = 400)
## IA.mostclone
ia.most <- samp.ia(most_clone, quiet = T, reps = 1000, n.snp = 400)

ia.unfiltered <- samp.ia(t1,  reps = 1000, quiet = T, n.snp = 400)
#ia.lin2 <- samp.ia(t2,  reps = 100, quiet = T, n.snp = 300)


# Summarizing data frames
d1 <- data.frame(ia.unfiltered , rep("xn.unfiltered", length(ia.unfiltered )))
d3 <- data.frame(ia.sex, rep("sexual", length(ia.sex)))
d4 <- data.frame(ia.clone, rep("clonal", length(ia.clone)))
d5 <- data.frame(ia.semi, rep("most-clonal", length(ia.semi)))
d6 <- data.frame(ia.most, rep("semi-clonal", length(ia.semi)))
colnames(d1) <- c("ia","dset")
#colnames(d2) <- c("ia","dset")
colnames(d3) <- c("ia","dset")
colnames(d4) <- c("ia","dset")
colnames(d5) <- c("ia","dset")
colnames(d6) <- c("ia","dset")
ia.total <- rbind(d4, d6, d5, d3, d1)
#ia.total <- rbind(d1, d2, d3, d4, d5)

# Normality tests
frames <- list(as.data.frame(d1), as.data.frame(d3), as.data.frame(d4), as.data.frame(d5), as.data.frame(d6))
normality <- list()
for (i in 1:length(frames)){
  normality[[i]] <- shapiro.test(frames[[i]][,'ia'])
}

# Analysis of variance
anova.ia <- aov(lm(ia ~ dset, ia.total))
library(agricolae)
tukey <- HSD.test(anova.ia, "dset", alpha = 0.001)
tukey

#Tukey groups for plot
group_data <- tukey$groups[order(rownames(tukey$groups)),]

# Kluskal wallis test
#kruskal.test(ia ~ dset, ia.total), trt="dset")
k.test <- with(ia.total, kruskal(ia, dset, group = T, p.adj = "bon"))


# override one of the 'grey' elements using an index by name

ia.total.colors <- ia.total %>%
  mutate(Color = case_when(
    startsWith(dset, "clonal") ~ "#FFFFFF",
    startsWith(dset, "semi") ~ "#C1C1C1",
    startsWith(dset, "most") ~ "#6D6D6D",
    endsWith(dset, "sexual") ~ "#1E1E1E",
    startsWith(dset, "xn") ~ "red"
    ))


palette2_named = setNames(object = ia.total.colors$Color, nm = ia.total$dset)
#print(palette2_named)

#palette2_named['xn.unfiltered.maf.lin1'] = '#1B9E77'
#print(palette2_named)

#ia.total <- ia.total[order(ia.total$ia), ] 
#ia.total <- arrange(ia.total, -ia, dset) 

#Reorder dataset for legend
ia.total$dset  <- with(ia.total, reorder(dset, -ia))

# Plot
gg2 <- ggplot(ia.total,aes(x=reorder(dset,-ia), y=ia,fill=dset)) + 
  xlab("Dataset") + ylab("Index of association") + 
  #scale_fill_grey()
  scale_fill_manual(values=palette2_named) +
  #geom_text(data = data.frame(),
           # aes(x = rownames(group_data), y = max(ia.total$ia), label = group_data$groups),
           # col = 'black',
           # size = 10) +
  geom_boxplot()
gg2
```

### Lineage 1 (Unfiltered)

```{r}
setPop(gl.necrophora) <-  ~Hyp_Final

t <- seppop(gl.necrophora)
t1 <- clonecorrect(as.snpclone(t$Lin1))


set.seed(100)
sex <- glSim(n.ind = nInd(t1), n.snp.nonstruc = ceiling(0.9*nLoc(t1)), n.snp.struc = floor(0.1*nLoc(t1)), ploidy=1, LD=TRUE)
### Structure (clonal pops)
clone <- glSim(nInd(t1), n.snp.nonstruc = floor(0.1*nLoc(t1)), n.snp.struc=ceiling(0.9*nLoc(t1)), ploidy=1, LD = T)
### Semi-clonal 
semi_clone <- glSim(nInd(t1),n.snp.nonstruc = 0.5*nLoc(t1), n.snp.struc= 0.5*nLoc(t1), ploidy=1, LD=T)
### Most-clonal 
most_clone <- glSim(nInd(t1), n.snp.nonstruc = ceiling(nLoc(t1)/3), n.snp.struc=2*nLoc(t1)/3, ploidy=1, LD=T)

## IA sex
ia.sex <- samp.ia(sex,quiet = T, reps = 1000, n.snp = 400)
## IA clone
ia.clone <- samp.ia(clone, quiet = T, reps = 1000, n.snp = 400)
## IA.semiclone
ia.semi <- samp.ia(semi_clone, quiet = T,reps = 1000, n.snp = 400)
## IA.mostclone
ia.most <- samp.ia(most_clone, quiet = T, reps = 1000, n.snp = 400)

ia.lin1<- samp.ia(t1,  reps = 1000, quiet = T, n.snp = 400)
#ia.lin2 <- samp.ia(t2,  reps = 100, quiet = T, n.snp = 300)


# Summarizing data frames
d1 <- data.frame(ia.lin1 , rep("xn.unfiltered.lin1", length(ia.lin1)))
d3 <- data.frame(ia.sex, rep("sexual", length(ia.sex)))
d4 <- data.frame(ia.clone, rep("clonal", length(ia.clone)))
d5 <- data.frame(ia.semi, rep("most-clonal", length(ia.semi)))
d6 <- data.frame(ia.most, rep("semi-clonal", length(ia.semi)))
colnames(d1) <- c("ia","dset")
#colnames(d2) <- c("ia","dset")
colnames(d3) <- c("ia","dset")
colnames(d4) <- c("ia","dset")
colnames(d5) <- c("ia","dset")
colnames(d6) <- c("ia","dset")
ia.total <- rbind(d4, d6, d5, d3, d1)
#ia.total <- rbind(d1, d2, d3, d4, d5)

# Normality tests
frames <- list(as.data.frame(d1), as.data.frame(d3), as.data.frame(d4), as.data.frame(d5), as.data.frame(d6))
normality <- list()
for (i in 1:length(frames)){
  normality[[i]] <- shapiro.test(frames[[i]][,'ia'])
}

# Analysis of variance
anova.ia <- aov(lm(ia ~ dset, ia.total))
library(agricolae)
tukey <- HSD.test(anova.ia, "dset", alpha = 0.001)
tukey

# Kluskal wallis test
#kruskal.test(ia ~ dset, ia.total), trt="dset")
k.test <- with(ia.total, kruskal(ia, dset, group = T, p.adj = "bon"))


# override one of the 'grey' elements using an index by name

ia.total.colors <- ia.total %>%
  mutate(Color = case_when(
    startsWith(dset, "clonal") ~ "#FFFFFF",
    startsWith(dset, "semi") ~ "#C1C1C1",
    startsWith(dset, "most") ~ "#6D6D6D",
    endsWith(dset, "sexual") ~ "#1E1E1E",
    startsWith(dset, "xn") ~ "#1B9E77"
    ))


palette2_named = setNames(object = ia.total.colors$Color, nm = ia.total$dset)
#print(palette2_named)

#palette2_named['xn.unfiltered.maf.lin1'] = '#1B9E77'
#print(palette2_named)

#ia.total <- ia.total[order(ia.total$ia), ] 
#ia.total <- arrange(ia.total, -ia, dset) 

#Reorder dataset for legend
ia.total$dset  <- with(ia.total, reorder(dset, -ia))

# Plot
gg2 <- ggplot(ia.total,aes(x=reorder(dset,-ia), y=ia,fill=dset)) + geom_boxplot() + 
  xlab("Dataset") + ylab("Index of association") + 
  #scale_fill_grey()
  scale_fill_manual(values=palette2_named)
gg2
```

### Lineage 2 (unfiltered)

```{r}
setPop(gl.necrophora) <-~Hyp_Final

t <- seppop(gl.necrophora)
t1 <- clonecorrect(as.snpclone(t$Lin2))


set.seed(100)
sex <- glSim(n.ind = nInd(t1), n.snp.nonstruc = ceiling(0.9*nLoc(t1)), n.snp.struc = floor(0.1*nLoc(t1)), ploidy=1, LD=TRUE)
### Structure (clonal pops)
clone <- glSim(nInd(t1), n.snp.nonstruc = floor(0.1*nLoc(t1)), n.snp.struc=ceiling(0.9*nLoc(t1)), ploidy=1, LD = T)
### Semi-clonal 
semi_clone <- glSim(nInd(t1),n.snp.nonstruc = 0.5*nLoc(t1), n.snp.struc= 0.5*nLoc(t1), ploidy=1, LD=T)
### Most-clonal 
most_clone <- glSim(nInd(t1), n.snp.nonstruc = ceiling(nLoc(t1)/3), n.snp.struc=2*nLoc(t1)/3, ploidy=1, LD=T)

## IA sex
ia.sex <- samp.ia(sex,quiet = T, reps = 1000, n.snp = 400)
## IA clone
ia.clone <- samp.ia(clone, quiet = T, reps = 1000, n.snp = 400)
## IA.semiclone
ia.semi <- samp.ia(semi_clone, quiet = T,reps = 1000, n.snp = 400)
## IA.mostclone
ia.most <- samp.ia(most_clone, quiet = T, reps = 1000, n.snp = 400)

ia.lin2<- samp.ia(t1,  reps = 1000, quiet = T, n.snp = 400)
#ia.lin2 <- samp.ia(t2,  reps = 100, quiet = T, n.snp = 300)


# Summarizing data frames
d1 <- data.frame(ia.lin2 , rep("xn.unfiltered.lin2", length(ia.lin2)))
d3 <- data.frame(ia.sex, rep("sexual", length(ia.sex)))
d4 <- data.frame(ia.clone, rep("clonal", length(ia.clone)))
d5 <- data.frame(ia.semi, rep("most-clonal", length(ia.semi)))
d6 <- data.frame(ia.most, rep("semi-clonal", length(ia.semi)))
colnames(d1) <- c("ia","dset")
#colnames(d2) <- c("ia","dset")
colnames(d3) <- c("ia","dset")
colnames(d4) <- c("ia","dset")
colnames(d5) <- c("ia","dset")
colnames(d6) <- c("ia","dset")
ia.total <- rbind(d4, d6, d5, d3, d1)
#ia.total <- rbind(d1, d2, d3, d4, d5)

# Normality tests
frames <- list(as.data.frame(d1), as.data.frame(d3), as.data.frame(d4), as.data.frame(d5), as.data.frame(d6))
normality <- list()
for (i in 1:length(frames)){
  normality[[i]] <- shapiro.test(frames[[i]][,'ia'])
}

# Analysis of variance
anova.ia <- aov(lm(ia ~ dset, ia.total))
library(agricolae)
tukey <- HSD.test(anova.ia, "dset", alpha = 0.001)
tukey
# Kluskal wallis test
#kruskal.test(ia ~ dset, ia.total), trt="dset")
k.test <- with(ia.total, kruskal(ia, dset, group = T, p.adj = "bon"))


# override one of the 'grey' elements using an index by name

ia.total.colors <- ia.total %>%
  mutate(Color = case_when(
    startsWith(dset, "clonal") ~ "#FFFFFF",
    startsWith(dset, "semi") ~ "#C1C1C1",
    startsWith(dset, "most") ~ "#6D6D6D",
    endsWith(dset, "sexual") ~ "#1E1E1E",
    startsWith(dset, "xn") ~ "#D95F02"
  ))


palette2_named = setNames(object = ia.total.colors$Color, nm = ia.total$dset)
#print(palette2_named)

#palette2_named['xn.filtered.maf.lin2'] = '#D95F02'
#print(palette2_named)

#ia.total <- ia.total[order(ia.total$ia), ] 
#ia.total <- arrange(ia.total, -ia, dset) 

#Reorder dataset for legend
ia.total$dset  <- with(ia.total, reorder(dset, -ia))

# Plot
gg2 <- ggplot(ia.total,aes(x=reorder(dset,-ia), y=ia,fill=dset)) + geom_boxplot() + 
  xlab("Dataset") + ylab("Index of association") + 
  #scale_fill_grey()
  scale_fill_manual(values=palette2_named)
gg2
```

## Lineage 3 (unfiltered)

```{r}
setPop(gl.necrophora) <-  ~Hyp_Final

t <- seppop(gl.necrophora)
t1 <- clonecorrect(as.snpclone(t$Lin3))


set.seed(100)
sex <- glSim(n.ind = nInd(t1), n.snp.nonstruc = ceiling(0.9*nLoc(t1)), n.snp.struc = floor(0.1*nLoc(t1)), ploidy=1, LD=TRUE)
### Structure (clonal pops)
clone <- glSim(nInd(t1), n.snp.nonstruc = floor(0.1*nLoc(t1)), n.snp.struc=ceiling(0.9*nLoc(t1)), ploidy=1, LD = T)
### Semi-clonal 
semi_clone <- glSim(nInd(t1),n.snp.nonstruc = 0.5*nLoc(t1), n.snp.struc= 0.5*nLoc(t1), ploidy=1, LD=T)
### Most-clonal 
most_clone <- glSim(nInd(t1), n.snp.nonstruc = ceiling(nLoc(t1)/3), n.snp.struc=2*nLoc(t1)/3, ploidy=1, LD=T)

## IA sex
ia.sex <- samp.ia(sex,quiet = T, reps = 1000, n.snp = 400)
## IA clone
ia.clone <- samp.ia(clone, quiet = T, reps = 1000, n.snp = 400)
## IA.semiclone
ia.semi <- samp.ia(semi_clone, quiet = T,reps = 1000, n.snp = 400)
## IA.mostclone
ia.most <- samp.ia(most_clone, quiet = T, reps = 1000, n.snp = 400)

ia.lin3<- samp.ia(t1,  reps = 1000, quiet = T, n.snp = 400)
#ia.lin2 <- samp.ia(t2,  reps = 100, quiet = T, n.snp = 300)


# Summarizing data frames
d1 <- data.frame(ia.lin3 , rep("xn.unfiltered.lin3", length(ia.lin3)))
d3 <- data.frame(ia.sex, rep("sexual", length(ia.sex)))
d4 <- data.frame(ia.clone, rep("clonal", length(ia.clone)))
d5 <- data.frame(ia.semi, rep("most-clonal", length(ia.semi)))
d6 <- data.frame(ia.most, rep("semi-clonal", length(ia.semi)))
colnames(d1) <- c("ia","dset")
#colnames(d2) <- c("ia","dset")
colnames(d3) <- c("ia","dset")
colnames(d4) <- c("ia","dset")
colnames(d5) <- c("ia","dset")
colnames(d6) <- c("ia","dset")
ia.total <- rbind(d4, d6, d5, d3, d1)
#ia.total <- rbind(d1, d2, d3, d4, d5)

# Normality tests
frames <- list(as.data.frame(d1), as.data.frame(d3), as.data.frame(d4), as.data.frame(d5), as.data.frame(d6))
normality <- list()
for (i in 1:length(frames)){
  normality[[i]] <- shapiro.test(frames[[i]][,'ia'])
}

# Analysis of variance
anova.ia <- aov(lm(ia ~ dset, ia.total))
library(agricolae)
tukey <- HSD.test(anova.ia, "dset", alpha = 0.001)
tukey
# Kluskal wallis test
#kruskal.test(ia ~ dset, ia.total), trt="dset")
k.test <- with(ia.total, kruskal(ia, dset, group = T, p.adj = "bon"))


# override one of the 'grey' elements using an index by name

ia.total.colors <- ia.total %>%
  mutate(Color = case_when(
    startsWith(dset, "clonal") ~ "#FFFFFF",
    startsWith(dset, "semi") ~ "#C1C1C1",
    startsWith(dset, "most") ~ "#6D6D6D",
    endsWith(dset, "sexual") ~ "#1E1E1E",
    startsWith(dset, "xn") ~ "#7570B3"
  ))


palette2_named = setNames(object = ia.total.colors$Color, nm = ia.total$dset)
#print(palette2_named)

#palette2_named['xn.filtered.maf.lin3'] = '#D95F02'
#print(palette2_named)

#ia.total <- ia.total[order(ia.total$ia), ] 
#ia.total <- arrange(ia.total, -ia, dset) 

#Reorder dataset for legend
ia.total$dset  <- with(ia.total, reorder(dset, -ia))

# Plot
gg2 <- ggplot(ia.total,aes(x=reorder(dset,-ia), y=ia,fill=dset)) + geom_boxplot() + 
  xlab("Dataset") + ylab("Index of association") + 
  #scale_fill_grey()
  scale_fill_manual(values=palette2_named)
gg2
```

# Estimating Index of Association for filtered dataset

Same as above for filtered dataset (159 individuals)


```{r}
#t <- seppop(gl.necrophora)
t1 <- clonecorrect(as.snpclone(gl.necrophora.filtered))
#t2 <- clonecorrect(as.snpclone(t$Lin2))

set.seed(100)
sex <- glSim(n.ind = nInd(t1), n.snp.nonstruc = ceiling(0.9*nLoc(t1)), n.snp.struc = floor(0.1*nLoc(t1)), ploidy=1, LD=TRUE)
### Structure (clonal pops)
clone <- glSim(nInd(t1), n.snp.nonstruc = floor(0.1*nLoc(t1)), n.snp.struc=ceiling(0.9*nLoc(t1)), ploidy=1, LD = T)
### Semi-clonal 
semi_clone <- glSim(nInd(t1),n.snp.nonstruc = 0.5*nLoc(t1), n.snp.struc= 0.5*nLoc(t1), ploidy=1, LD=T)
### Most-clonal 
most_clone <- glSim(nInd(t1), n.snp.nonstruc = ceiling(nLoc(t1)/3), n.snp.struc=2*nLoc(t1)/3, ploidy=1, LD=T)

## IA sex
ia.sex <- samp.ia(sex,quiet = T, reps = 1000, n.snp = 400)
## IA clone
ia.clone <- samp.ia(clone, quiet = T, reps = 1000, n.snp = 400)
## IA.semiclone
ia.semi <- samp.ia(semi_clone, quiet = T,reps = 1000, n.snp = 400)
## IA.mostclone
ia.most <- samp.ia(most_clone, quiet = T, reps = 1000, n.snp = 400)

ia.filtered <- samp.ia(t1,  reps = 1000, quiet = T, n.snp = 400)
#ia.lin2 <- samp.ia(t2,  reps = 100, quiet = T, n.snp = 300)


# Summarizing data frames
d1 <- data.frame(ia.filtered, rep("xn.filtered", length(ia.filtered)))
d3 <- data.frame(ia.sex, rep("sexual", length(ia.sex)))
d4 <- data.frame(ia.clone, rep("clonal", length(ia.clone)))
d5 <- data.frame(ia.semi, rep("most-clonal", length(ia.semi)))
d6 <- data.frame(ia.most, rep("semi-clonal", length(ia.semi)))
colnames(d1) <- c("ia","dset")
#colnames(d2) <- c("ia","dset")
colnames(d3) <- c("ia","dset")
colnames(d4) <- c("ia","dset")
colnames(d5) <- c("ia","dset")
colnames(d6) <- c("ia","dset")
ia.total <- rbind(d4, d6, d5, d3, d1)
#ia.total <- rbind(d1, d2, d3, d4, d5)

# Normality tests
frames <- list(as.data.frame(d1), as.data.frame(d3), as.data.frame(d4), as.data.frame(d5), as.data.frame(d6))
normality <- list()
for (i in 1:length(frames)){
  normality[[i]] <- shapiro.test(frames[[i]][,'ia'])
}

# Analysis of variance
anova.ia <- aov(lm(ia ~ dset, ia.total))
library(agricolae)
tukey <- HSD.test(anova.ia, "dset", alpha = 0.001)
tukey
# Kluskal wallis test
#kruskal.test(ia ~ dset, ia.total), trt="dset")
k.test <- with(ia.total, kruskal(ia, dset, group = T, p.adj = "bon"))

# override one of the 'grey' elements using an index by name

ia.total.colors <- ia.total %>%
  mutate(Color = case_when(
    startsWith(dset, "clonal") ~ "#FFFFFF",
    startsWith(dset, "semi") ~ "#C1C1C1",
    startsWith(dset, "most") ~ "#6D6D6D",
    endsWith(dset, "sexual") ~ "#1E1E1E",
    startsWith(dset, "xn") ~ "red"
    ))


palette2_named = setNames(object = ia.total.colors$Color, nm = ia.total$dset)
#print(palette2_named)

#palette2_named['xn.unfiltered.maf.lin1'] = '#1B9E77'
#print(palette2_named)

#ia.total <- ia.total[order(ia.total$ia), ] 
#ia.total <- arrange(ia.total, -ia, dset) 

#Reorder dataset for legend
ia.total$dset  <- with(ia.total, reorder(dset, -ia))

# Plot
gg2 <- ggplot(ia.total,aes(x=reorder(dset,-ia), y=ia,fill=dset)) + geom_boxplot() + 
  xlab("Dataset") + ylab("Index of association") + 
  #scale_fill_grey()
  scale_fill_manual(values=palette2_named)
gg2
```

### Lineage 1 (Filtered)

```{r}
setPop(gl.necrophora.filtered) <-  ~Hyp_Final

t <- seppop(gl.necrophora.filtered)
t1 <- clonecorrect(as.snpclone(t$Lin1))


set.seed(100)
sex <- glSim(n.ind = nInd(t1), n.snp.nonstruc = ceiling(0.9*nLoc(t1)), n.snp.struc = floor(0.1*nLoc(t1)), ploidy=1, LD=TRUE)
### Structure (clonal pops)
clone <- glSim(nInd(t1), n.snp.nonstruc = floor(0.1*nLoc(t1)), n.snp.struc=ceiling(0.9*nLoc(t1)), ploidy=1, LD = T)
### Semi-clonal 
semi_clone <- glSim(nInd(t1),n.snp.nonstruc = 0.5*nLoc(t1), n.snp.struc= 0.5*nLoc(t1), ploidy=1, LD=T)
### Most-clonal 
most_clone <- glSim(nInd(t1), n.snp.nonstruc = ceiling(nLoc(t1)/3), n.snp.struc=2*nLoc(t1)/3, ploidy=1, LD=T)

## IA sex
ia.sex <- samp.ia(sex,quiet = T, reps = 1000, n.snp = 400)
## IA clone
ia.clone <- samp.ia(clone, quiet = T, reps = 1000, n.snp = 400)
## IA.semiclone
ia.semi <- samp.ia(semi_clone, quiet = T,reps = 1000, n.snp = 400)
## IA.mostclone
ia.most <- samp.ia(most_clone, quiet = T, reps = 1000, n.snp = 400)

ia.lin1<- samp.ia(t1,  reps = 1000, quiet = T, n.snp = 400)
#ia.lin2 <- samp.ia(t2,  reps = 100, quiet = T, n.snp = 300)


# Summarizing data frames
d1 <- data.frame(ia.lin1 , rep("xn.filtered.lin1", length(ia.lin1)))
d3 <- data.frame(ia.sex, rep("sexual", length(ia.sex)))
d4 <- data.frame(ia.clone, rep("clonal", length(ia.clone)))
d5 <- data.frame(ia.semi, rep("most-clonal", length(ia.semi)))
d6 <- data.frame(ia.most, rep("semi-clonal", length(ia.semi)))
colnames(d1) <- c("ia","dset")
#colnames(d2) <- c("ia","dset")
colnames(d3) <- c("ia","dset")
colnames(d4) <- c("ia","dset")
colnames(d5) <- c("ia","dset")
colnames(d6) <- c("ia","dset")
ia.total <- rbind(d4, d6, d5, d3, d1)
#ia.total <- rbind(d1, d2, d3, d4, d5)

# Normality tests
frames <- list(as.data.frame(d1), as.data.frame(d3), as.data.frame(d4), as.data.frame(d5), as.data.frame(d6))
normality <- list()
for (i in 1:length(frames)){
  normality[[i]] <- shapiro.test(frames[[i]][,'ia'])
}

# Analysis of variance
anova.ia <- aov(lm(ia ~ dset, ia.total))
library(agricolae)
tukey <- HSD.test(anova.ia, "dset", alpha = 0.001)
tukey

# Kluskal wallis test
#kruskal.test(ia ~ dset, ia.total), trt="dset")
k.test <- with(ia.total, kruskal(ia, dset, group = T, p.adj = "bon"))


# override one of the 'grey' elements using an index by name

ia.total.colors <- ia.total %>%
  mutate(Color = case_when(
    startsWith(dset, "clonal") ~ "#FFFFFF",
    startsWith(dset, "semi") ~ "#C1C1C1",
    startsWith(dset, "most") ~ "#6D6D6D",
    endsWith(dset, "sexual") ~ "#1E1E1E",
    startsWith(dset, "xn") ~ "#1B9E77"
    ))


palette2_named = setNames(object = ia.total.colors$Color, nm = ia.total$dset)
#print(palette2_named)

#palette2_named['xn.unfiltered.maf.lin1'] = '#1B9E77'
#print(palette2_named)

#ia.total <- ia.total[order(ia.total$ia), ] 
#ia.total <- arrange(ia.total, -ia, dset) 

#Reorder dataset for legend
ia.total$dset  <- with(ia.total, reorder(dset, -ia))

# Plot
gg2 <- ggplot(ia.total,aes(x=reorder(dset,-ia), y=ia,fill=dset)) + geom_boxplot() + 
  xlab("Dataset") + ylab("Index of association") + 
  #scale_fill_grey()
  scale_fill_manual(values=palette2_named)
gg2
```

### Lineage 2 (filtered)

```{r}
setPop(gl.necrophora.filtered) <-~Hyp_Final

t <- seppop(gl.necrophora.filtered)
t1 <- clonecorrect(as.snpclone(t$Lin2))


set.seed(100)
sex <- glSim(n.ind = nInd(t1), n.snp.nonstruc = ceiling(0.9*nLoc(t1)), n.snp.struc = floor(0.1*nLoc(t1)), ploidy=1, LD=TRUE)
### Structure (clonal pops)
clone <- glSim(nInd(t1), n.snp.nonstruc = floor(0.1*nLoc(t1)), n.snp.struc=ceiling(0.9*nLoc(t1)), ploidy=1, LD = T)
### Semi-clonal 
semi_clone <- glSim(nInd(t1),n.snp.nonstruc = 0.5*nLoc(t1), n.snp.struc= 0.5*nLoc(t1), ploidy=1, LD=T)
### Most-clonal 
most_clone <- glSim(nInd(t1), n.snp.nonstruc = ceiling(nLoc(t1)/3), n.snp.struc=2*nLoc(t1)/3, ploidy=1, LD=T)

## IA sex
ia.sex <- samp.ia(sex,quiet = T, reps = 1000, n.snp = 400)
## IA clone
ia.clone <- samp.ia(clone, quiet = T, reps = 1000, n.snp = 400)
## IA.semiclone
ia.semi <- samp.ia(semi_clone, quiet = T,reps = 1000, n.snp = 400)
## IA.mostclone
ia.most <- samp.ia(most_clone, quiet = T, reps = 1000, n.snp = 400)

ia.lin2<- samp.ia(t1,  reps = 1000, quiet = T, n.snp = 400)
#ia.lin2 <- samp.ia(t2,  reps = 100, quiet = T, n.snp = 300)


# Summarizing data frames
d1 <- data.frame(ia.lin2 , rep("xn.filtered.lin2", length(ia.lin2)))
d3 <- data.frame(ia.sex, rep("sexual", length(ia.sex)))
d4 <- data.frame(ia.clone, rep("clonal", length(ia.clone)))
d5 <- data.frame(ia.semi, rep("most-clonal", length(ia.semi)))
d6 <- data.frame(ia.most, rep("semi-clonal", length(ia.semi)))
colnames(d1) <- c("ia","dset")
#colnames(d2) <- c("ia","dset")
colnames(d3) <- c("ia","dset")
colnames(d4) <- c("ia","dset")
colnames(d5) <- c("ia","dset")
colnames(d6) <- c("ia","dset")
ia.total <- rbind(d4, d6, d5, d3, d1)
#ia.total <- rbind(d1, d2, d3, d4, d5)

# Normality tests
frames <- list(as.data.frame(d1), as.data.frame(d3), as.data.frame(d4), as.data.frame(d5), as.data.frame(d6))
normality <- list()
for (i in 1:length(frames)){
  normality[[i]] <- shapiro.test(frames[[i]][,'ia'])
}

# Analysis of variance
anova.ia <- aov(lm(ia ~ dset, ia.total))
library(agricolae)
tukey <- HSD.test(anova.ia, "dset", alpha = 0.001)
tukey
# Kluskal wallis test
#kruskal.test(ia ~ dset, ia.total), trt="dset")
k.test <- with(ia.total, kruskal(ia, dset, group = T, p.adj = "bon"))


# override one of the 'grey' elements using an index by name

ia.total.colors <- ia.total %>%
  mutate(Color = case_when(
    startsWith(dset, "clonal") ~ "#FFFFFF",
    startsWith(dset, "semi") ~ "#C1C1C1",
    startsWith(dset, "most") ~ "#6D6D6D",
    endsWith(dset, "sexual") ~ "#1E1E1E",
    startsWith(dset, "xn") ~ "#D95F02"
  ))


palette2_named = setNames(object = ia.total.colors$Color, nm = ia.total$dset)
#print(palette2_named)

#palette2_named['xn.filtered.maf.lin2'] = '#D95F02'
#print(palette2_named)

#ia.total <- ia.total[order(ia.total$ia), ] 
#ia.total <- arrange(ia.total, -ia, dset) 

#Reorder dataset for legend
ia.total$dset  <- with(ia.total, reorder(dset, -ia))

# Plot
gg2 <- ggplot(ia.total,aes(x=reorder(dset,-ia), y=ia,fill=dset)) + geom_boxplot() + 
  xlab("Dataset") + ylab("Index of association") + 
  #scale_fill_grey()
  scale_fill_manual(values=palette2_named)
gg2
```

## Lineage 3 (filtered)

```{r}
setPop(gl.necrophora.filtered) <-  ~Hyp_Final

t <- seppop(gl.necrophora.filtered)
t1 <- clonecorrect(as.snpclone(t$Lin3))


set.seed(100)
sex <- glSim(n.ind = nInd(t1), n.snp.nonstruc = ceiling(0.9*nLoc(t1)), n.snp.struc = floor(0.1*nLoc(t1)), ploidy=1, LD=TRUE)
### Structure (clonal pops)
clone <- glSim(nInd(t1), n.snp.nonstruc = floor(0.1*nLoc(t1)), n.snp.struc=ceiling(0.9*nLoc(t1)), ploidy=1, LD = T)
### Semi-clonal 
semi_clone <- glSim(nInd(t1),n.snp.nonstruc = 0.5*nLoc(t1), n.snp.struc= 0.5*nLoc(t1), ploidy=1, LD=T)
### Most-clonal 
most_clone <- glSim(nInd(t1), n.snp.nonstruc = ceiling(nLoc(t1)/3), n.snp.struc=2*nLoc(t1)/3, ploidy=1, LD=T)

## IA sex
ia.sex <- samp.ia(sex,quiet = T, reps = 1000, n.snp = 400)
## IA clone
ia.clone <- samp.ia(clone, quiet = T, reps = 1000, n.snp = 400)
## IA.semiclone
ia.semi <- samp.ia(semi_clone, quiet = T,reps = 1000, n.snp = 400)
## IA.mostclone
ia.most <- samp.ia(most_clone, quiet = T, reps = 1000, n.snp = 400)

ia.lin3<- samp.ia(t1,  reps = 1000, quiet = T, n.snp = 400)
#ia.lin2 <- samp.ia(t2,  reps = 100, quiet = T, n.snp = 300)


# Summarizing data frames
d1 <- data.frame(ia.lin3 , rep("xn.filtered.lin3", length(ia.lin3)))
d3 <- data.frame(ia.sex, rep("sexual", length(ia.sex)))
d4 <- data.frame(ia.clone, rep("clonal", length(ia.clone)))
d5 <- data.frame(ia.semi, rep("most-clonal", length(ia.semi)))
d6 <- data.frame(ia.most, rep("semi-clonal", length(ia.semi)))
colnames(d1) <- c("ia","dset")
#colnames(d2) <- c("ia","dset")
colnames(d3) <- c("ia","dset")
colnames(d4) <- c("ia","dset")
colnames(d5) <- c("ia","dset")
colnames(d6) <- c("ia","dset")
ia.total <- rbind(d4, d6, d5, d3, d1)
#ia.total <- rbind(d1, d2, d3, d4, d5)

# Normality tests
frames <- list(as.data.frame(d1), as.data.frame(d3), as.data.frame(d4), as.data.frame(d5), as.data.frame(d6))
normality <- list()
for (i in 1:length(frames)){
  normality[[i]] <- shapiro.test(frames[[i]][,'ia'])
}

# Analysis of variance
anova.ia <- aov(lm(ia ~ dset, ia.total))
library(agricolae)
tukey <- HSD.test(anova.ia, "dset", alpha = 0.001)
tukey
# Kluskal wallis test
#kruskal.test(ia ~ dset, ia.total), trt="dset")
k.test <- with(ia.total, kruskal(ia, dset, group = T, p.adj = "bon"))


# override one of the 'grey' elements using an index by name

ia.total.colors <- ia.total %>%
  mutate(Color = case_when(
    startsWith(dset, "clonal") ~ "#FFFFFF",
    startsWith(dset, "semi") ~ "#C1C1C1",
    startsWith(dset, "most") ~ "#6D6D6D",
    endsWith(dset, "sexual") ~ "#1E1E1E",
    startsWith(dset, "xn") ~ "#7570B3"
  ))


palette2_named = setNames(object = ia.total.colors$Color, nm = ia.total$dset)
#print(palette2_named)

#palette2_named['xn.filtered.maf.lin3'] = '#D95F02'
#print(palette2_named)

#ia.total <- ia.total[order(ia.total$ia), ] 
#ia.total <- arrange(ia.total, -ia, dset) 

#Reorder dataset for legend
ia.total$dset  <- with(ia.total, reorder(dset, -ia))

# Plot
gg2 <- ggplot(ia.total,aes(x=reorder(dset,-ia), y=ia,fill=dset)) + geom_boxplot() + 
  xlab("Dataset") + ylab("Index of association") + 
  #scale_fill_grey()
  scale_fill_manual(values=palette2_named)
gg2
```
